
def getPublicKey(): #to generate (e and n)/ this is the public key pair
    p = 293
    q = 283
    e = 5000
    n = p*q;
    print("n value =",n)
    print("e value =",e)
    return e,n
    
def getPrivateKey(): #to generate (d) but first generating phi
    p = 53
    q = 47
    e = 5000
    phi = (p-1)*(q-1)
    d = pow(e,-1,phi)
    return d   

def genSignature(msg,d,n): #generates a signature for a legit message
    sig_t = msg ** d
    sig = (sig_t % n) #signature is the encryption of the message using the private key
    print("Signature is",sig)
    return sig

def verifySignature(msg,e,sig,n): #to verify a message
    msg_prime = ((sig ** e) % n) #gets the message from the signature by decrypting with the public key
    msg_prime = round(msg_prime)
    print (msg_prime)
    if (msg == msg_prime): #compares the original message with the computed one (msg_prime)
        print("Message is valid")
    else: print("invalid message")

def forgedSignature(msg,e): #Creates a forged signature to a message
    f_sig = (msg ** (1/e)) #since e = 3 and its a small value. We can get a forged signature by calculating the cube root of the message
    print("Forged Signature =",f_sig)
    return f_sig

print("Welcome!\n1.generate signature and verify using legal means"+
"\n2.forge a valid signature as an illegal user using the e = 3 exploit")

option = input("choose an option\n")

if (option == '1'): #it gets a message and calculates the signature using the legal method (private key is with the user)
    msg = int(input("please enter a message\n"))
    e,n = getPublicKey()
    d = getPrivateKey()
    if (msg > n-1): #for an input to be rsa valid it must be less than n-1
        print("x")
        msg = (msg % n)
    print(d)
    signature = genSignature(msg,d,n) #generates signature with private key  
    verifySignature(msg,e,signature,n) #verifies the integrity

elif(option == '2'):
    msg = int(input("please enter a message\n"))
    e,n = getPublicKey()
    if (msg > n-1): #for an input to be rsa valid it must be less than n-1
        msg = (msg % n)
    signature = forgedSignature(msg,e) #generates forged signature with no knowledge of the private key
    verifySignature(msg,e,signature,n) #verifies the integrity of the forged signature
else:
    print("invalid input")    

     
