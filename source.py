from math import gcd
from time import sleep

from sympy import isprime


p = 1103  # large value for p
q = 1097  # large value for q


def getPublicKey():  # to generate (n)/ this gives us the public key pair (n,e)
    n = p*q
    print("n value =", n)
    print("e value =", e)
    return e, n


def getPrivateKey():  # to generate (d) but first generating phi
    phi = (p-1)*(q-1)
    d = pow(e, -1, phi)
    return d


def genSignature(msg, d, n):  # generates a signature for a legit message
    # signature is the encryption of the message using the private key
    sig = ((msg ** d) % n)
    return sig


def verifySignature(msg, sig, e, n):  # to verify a message
    # gets the message from the signature by decrypting with the public key
    msg_prime = ((sig ** e) % n)
    msg_prime = round(msg_prime)
    if (msg == msg_prime):  # compares the original message with the computed one (msg_prime)
        return True
    else:
        return False


def forgedSignature(msg, e):  # Creates a forged signature to a message
    # since e = 3 and its a small value. We can get a forged signature by calculating the cube root of the message
    f_sig = (msg ** (1/e))
    return f_sig

#declare values for e,p,q
e = int(input("Hello!\nplease enter a value for e\n")) #recommended e = 3
p = int(input("please enter a value for p\n"))         #recommended p = 1103
q = int(input("please enter a value for q\n"))         #recommended q = 1097

if (gcd(e,((p-1)*(q-1))) != 1 & isprime(p) & isprime(q)):
    print("gcd between e and (p-1*q-1) isn't 1 or that p or q isn't prime, please enter correct values")

else:    
    print("Welcome!\ne = {} and n = {}\n1.generate signature and verify using legal means".format(e, (p*q)))
    print("2.forge a valid signature as an illegal user using the e = {} exploit".format(e))

    option = input("choose an option\n")

    if (option == '1'):  # it gets a message and calculates the signature using the legal method (private key is with the user)
        msg = int(input("please enter a message\n"))
        e, n = getPublicKey()
        d = getPrivateKey()
        if (msg > n-1):  # for an input to be rsa valid it must be less than n-1
            msg = (msg % n)
        print(d)
        signature = genSignature(msg, d, n)  # generates signature with private key
        if (verifySignature(msg, signature, e, n)):  # verifies the integrity
            print("message is valid")
        else:
            print("invalid message")

    elif(option == '2'):
        e, n = getPublicKey()
        ctr = 0
        for i in range(2, n):
            msg = i
            signature = int(forgedSignature(msg, e))
            if (verifySignature(msg, signature, e, n)):  # verifies the integrity of the forged signature
                print(msg, "is verified using forged signature", signature)
                ctr += 1
        print(ctr, "value(s) found\n")

    else:
        print("invalid input")
    print("program will end in 4s")
    sleep(4)
